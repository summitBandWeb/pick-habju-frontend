name: Discord PR Open/Label Notify

on:
  pull_request:
    types: [opened, ready_for_review, labeled]

# ë¼ë²¨ 2ê°œ ë¶™ì´ë©´ labeled ì´ë²¤íŠ¸ 2ë²ˆ â†’ ë™ì‹œ ì‹¤í–‰ ì‹œ ë‘˜ ë‹¤ ì•Œë¦¼ ì „ì†¡. ê°™ì€ PRì€ ì§ë ¬ ì‹¤í–‰í•´ ë‘ ë²ˆì§¸ runì—ì„œ ë¼ë²¨ ë³´ê³  ìŠ¤í‚µ.
concurrency:
  group: pr-${{ github.event.pull_request.number }}
  cancel-in-progress: false

permissions:
  pull-requests: read
  issues: write
  contents: read

jobs:
  notify:
    if: ${{ github.event.pull_request.draft == false }}
    runs-on: ubuntu-latest
    steps:
      - name: Build & Send Discord message
        uses: actions/github-script@v7
        env:
          DISCORD_WEBHOOK_PR_ALERTS: ${{ secrets.DISCORD_WEBHOOK_PR_ALERTS }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const labels = (pr.labels || []).map(l => l.name);
            const action = context.payload.action;

            // âœ… í•˜ë“œì½”ë”© ë©˜ì…˜ (ê¸´ê¸‰ ì „ìš©)
            // ë””ìŠ¤ì½”ë“œ ìœ ì € ID ê¸°ë°˜ìœ¼ë¡œ <@ID> í˜•íƒœë¡œ ë„£ì–´ì•¼ í™•ì‹¤íˆ ë©˜ì…˜ë©ë‹ˆë‹¤.
            const URGENT_MENTIONS = [
                "<@317972480704774144>",
                "<@1221742784759988237>",
            ].join(" ");

            // Only notify on:
            // - opened / ready_for_review => always notify
            // - labeled => only when relevant labels added
            const isOpenEvent = (action === "opened" || action === "ready_for_review");
            const labeledName = context.payload.label?.name || "";
            const isRelevantLabelEvent =
              action === "labeled" && ["priority/high", "review/24h", "review/48h", "risk/high"].includes(labeledName);

            if (!isOpenEvent && !isRelevantLabelEvent) {
              core.info("Not an event we notify on.");
              return;
            }

            // labeled ì´ë²¤íŠ¸ëŠ” ë¼ë²¨ 1ê°œë§ˆë‹¤ 1ë²ˆ ë°œìƒ â†’ PRë‹¹ 1ë²ˆë§Œ ì•Œë¦¼ (ì§ë ¬ ì‹¤í–‰ + ìµœì‹  ë¼ë²¨ë¡œ ì¤‘ë³µ íŒë‹¨)
            const LABELED_NOTIFIED = "bot/discord-labeled-notified";
            if (action === "labeled") {
              const { data: fresh } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              const hasNotified = (fresh.labels || []).some(l => l.name === LABELED_NOTIFIED);
              if (hasNotified) {
                core.info("Already sent a labeled notification for this PR, skipping.");
                return;
              }
            }

            const hasPriorityHigh = labels.includes("priority/high");
            const hasReview24 = labels.includes("review/24h");
            const hasReview48 = labels.includes("review/48h");
            const hasRiskHigh = labels.includes("risk/high");

            // ê°•ì¡° ì•Œë¦¼ ì¡°ê±´: priority/high + review/24h or review/48h
            const isUrgent = hasPriorityHigh && (hasReview24 || hasReview48);
            const reviewWindow = hasReview24 ? "24h" : (hasReview48 ? "48h" : null);

            // âœ… ëª¨ë“  ì•Œë¦¼ì— ë¼ë²¨ í‘œì‹œ(í•„ë“œ)
            const labelText = labels.length ? labels.join(", ") : "(none)";

            let title = "ğŸ†• PRì´ ì˜¬ë¼ì™”ì–´ìš”";
            let content = ""; // ê¸°ë³¸ì€ ë©˜ì…˜ ì—†ìŒ

            if (isUrgent && reviewWindow) {
              title = `ğŸš¨ ê¸´ê¸‰ PR: ${reviewWindow} ë‚´ ì²« ë¦¬ë·°ê°€ í•„ìš”í•´ìš”`;
              content = URGENT_MENTIONS || "@here"; // ë©˜ì…˜ ë¦¬ìŠ¤íŠ¸ ë¹„ì–´ìˆìœ¼ë©´ @here fallback
            } else if (hasRiskHigh && (hasReview24 || hasReview48)) {
              // risk/high + review/* ìì²´ëŠ” "ê¸´ê¸‰"ê¹Œì§„ ì•„ë‹ˆì–´ë„ ì‹ í˜¸ëŠ” ì£¼ê¸°
              title = `ğŸŸ  ì£¼ì˜ PR: review/${reviewWindow || "?"} (risk/high)`;
              // ë©˜ì…˜ì€ ì•ˆ í•¨ (ì›í•˜ë©´ ì—¬ê¸°ì—ë„ ë©˜ì…˜ ë„£ì„ ìˆ˜ ìˆìŒ)
            }

            const payload = {
              content,
              embeds: [{
                title,
                url: pr.html_url,
                description: `**${pr.title}**\nPR #${pr.number} â€¢ ${pr.base.ref} â† ${pr.head.ref}`,
                fields: [
                  { name: "ì‘ì„±ì", value: pr.user.login, inline: true },
                  { name: "ë¼ë²¨", value: labelText, inline: false }
                ],
                timestamp: new Date().toISOString()
              }]
            };

            const webhook = process.env.DISCORD_WEBHOOK_PR_ALERTS;
            if (!webhook) throw new Error("Missing DISCORD_WEBHOOK_PR_ALERTS secret.");

            const res = await fetch(webhook, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });

            if (!res.ok) {
              const txt = await res.text();
              throw new Error(`Discord webhook failed: ${res.status} ${txt}`);
            }

            if (action === "labeled") {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: [LABELED_NOTIFIED]
                });
              } catch (e) {
                const status = e?.status ?? e?.response?.status;
                if (status === 404 || status === 422) {
                  try {
                    await github.rest.issues.createLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name: LABELED_NOTIFIED,
                      color: "ededed",
                      description: "internal: already sent Discord for labeled event"
                    });
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      labels: [LABELED_NOTIFIED]
                    });
                  } catch (_) {}
                }
              }
            }
